package com.sdww;

/**
 * ForkJoinPool属于并发大师Doug Lea于Java 1.7新增的并发框架Fork/Join的一部分
 * Fork/Join框架完全不同于原有的ExecutorService框架，其思想与MultiThread也不尽相同。
 * 它所关心的核心为task，task可以分裂/执行，适用于各种分治算法，递归算法。
 * 用户完全不用操心线程之间的同步问题，task的调度与同步均由Fork/Join框架自动完成。
 * Fork/Join框架最核心的算法是工作偷取(work-stealing)：线程不一定仅从某个task队列中获取task，它还会从其他的队列中偷取task来运行
 * 工作偷取机制保证了task之间尽量并发操作，保证了在最坏情况下task能够尽量被平均分配。从而提高了整个框架的执行效率。
 * 关于Fork/Join理论的相关说明请见:{@link http://github.com/oldratlee/translations/blob/master/a-java-fork-join-framework/README.md}
 * 其核心设计思想为：
 *      Fork/Join程序可以在任何支持以下特性的框架之上运行：框架能够让构建的子任务并行执行，并且拥有一种等待子任务运行结束的机制。
 *      然而，java.lang.Thread类（同时也包括POSIX pthread，这些也是Java线程所基于的基础）对Fork/Join程序来说并不是最优的选择：
 *      Fork/Join任务对同步和管理有简单的和常规的需求。相对于常规的线程来说，Fork/Join任务所展示的计算布局将会带来更加灵活的调度策略。
 *      例如，Fork/Join任务除了等待子任务外，其他情况下是不需要阻塞的。因此传统的用于跟踪记录阻塞线程的代价在这种情况下实际上是一种浪费。
 *      对于一个合理的基础任务粒度来说，构建和管理一个线程的代价甚至可以比任务执行本身所花费的代价更大。
 *      尽管粒度是应该随着应用程序在不同特定平台上运行而做出相应调整的。但是超过线程开销的极端粗粒度会限制并行的发挥。
 *      对于一个合理的基础任务粒度来说，构建和管理一个线程的代价甚至可以比任务执行本身所花费的代价更大。
 *      尽管粒度是应该随着应用程序在不同特定平台上运行而做出相应调整的。但是超过线程开销的极端粗粒度会限制并行的发挥。
 *      简而言之，Java标准的线程框架对Fork/Join程序而言太笨重了。但是既然线程构成了很多其他的并发和并行编程的基础，完全消除这种代价或者为了这种方式而调整线程调度是不可能（或者说不切实际的）。
 *      尽管这种思想已经存在了很长时间了，但是第一个发布的能系统解决这些问题的框架是Cilk。Cilk和其他轻量级的框架是基于操作系统的基本的线程和进程机制来支持特殊用途的Fork/Join程序。
 *      这种策略同样适用于Java，尽管Java线程是基于低级别的操作系统的能力来实现的。创造这样一个轻量级的执行框架的主要优势是能够让Fork/Join程序以一种更直观的方式编写，进而能够在各种支持JVM的系统上运行。
 *      FJTask框架是基于Cilk设计的一种演变。其他的类似框架有Hood、Filaments、Stackthreads以及一些依赖于轻量级执行任务的相关系统。
 *      所有这些框架都采用和操作系统把线程映射到CPU上相同的方式来把任务映射到线程上。只是他们会使用Fork/Join程序的简单性、常规性以及一致性来执行这种映射。
 *      尽管这些框架都能适应不能形式的并行程序，他们优化了Fork/Join的设计：
 *          1.一组工作者线程池是准备好的。每个工作线程都是标准的（『重量级』）处理存放在队列中任务的线程（这地方指的是Thread类的子类FJTaskRunner的实例对象）。
 *          通常情况下，工作线程应该与系统的处理器数量一致。对于一些原生的框架例如说Cilk，他们首先将映射成内核线程或者是轻量级的进程，然后再在处理器上面运行。
 *          在Java中，虚拟机和操作系统需要相互结合来完成线程到处理器的映射。然后对于计算密集型的运算来说，这种映射对于操作系统来说是一种相对简单的任务。
 *          任何合理的映射策略都会导致线程映射到不同的处理器。
 *          2.所有的Fork/Join任务都是轻量级执行类的实例，而不是线程实例。在Java中，独立的可执行任务必须要实现Runnable接口并重写run方法。
 *          在FJTask框架中，这些任务将作为子类继承FJTask而不是Thread，它们都实现了Runnable接口。
 *          （对于上面两种情况来说，一个类也可以选择实现Runnable接口，类的实例对象既可以在任务中执行也可以在线程中执行。
 *          因为任务执行受到来自FJTask方法严厉规则的制约，子类化FJTask相对来说更加方便，也能够直接调用它们。）
 *          3.我们将采用一个特殊的队列和调度原则来管理任务并通过工作线程来执行任务。这些机制是由任务类中提供的相关方式实现的：主要是由fork、join、
 *          isDone（一个结束状态的标示符），和一些其他方便的方法，例如调用coInvoke来分解合并两个或两个以上的任务。
 *          4.一个简单的控制和管理类（这里指的是FJTaskRunnerGroup）来启动工作线程池，并初始化执行一个由正常的线程调用所触发的Fork/Join任务（就类似于Java程序中的main方法）。
 */
public class ForkJoinPool {
}
